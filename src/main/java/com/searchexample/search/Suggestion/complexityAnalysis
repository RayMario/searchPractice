1、单词补全功能使用倒排索引实现，索引的key是字母，索引的value是单词id与该字母在该单词当中的位置。
    其中记录字母在当前单词的位置是为了验证是否满足“前缀关系”与“缩写关系”
    整个倒排表都在内存当中储存。因此应当只储存整数，内容放在数据库当中。
    单词id用int类型，字母在单词当中的位置使用List<Short>，因为单词长度较小，short足够存储位置
    目前没有使用bitmap结构，如果使用固定大小的bitmap，每个字母的倒排映射就需要100多MB，共3G多内存。
2、单词/短语内容储存在mysql上，构建表的sql语句如下：

CREATE TABLE `suggestions` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `word` varchar(128) NOT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `id_UNIQUE` (`id`,`word`)
) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci

3、其中id设置为自增的int变量，int类型的正数部分大约有20亿，对于常用的单词/短语是够用的。

4、由于java在整数上的基本类型只有short，int，long，倒排链当中的压缩方式比如差分压缩，
    分块差分压缩可能无法达到降低倒排链当中元素大小的目的，因此没有采用压缩方案。

5、倒排链的构建尝试了两种方案:
    1）一种是两级HashMap，其字母到单词id，单词id到当前字母在该单词当中的位置映射均为O(1)，HashMap本身可能占用内存较大
        1.1）总的查询时间应当是O（N*M*L），其中N为用户输入的单词的长度，M为字母对应的倒排索引单词个数，L为字母在某个单词中的位置列表长度。
        1.2）查询需要的额外空间为：输入的字母个数*字母对应的倒排链上的单词个数*（id占用内存（4字节）+字母在单词中位置（2字节））
        1.2） HashMap本身为了实现hash运算会保存较多额外的成员，因此整个倒排表的内存占用较大。但是查询时间较短

    2）另一种是利用两个ArrayList，字母到单词id的映射利用二分查找，如果倒排链当中存在这个单词id就返回其下标。
        该字母在该单词id下的位置保存在另外一个ArrayList<Short>当中，因为单词/短语在数据库中定义最高长度为128字节，因此使用short就足够表示位置。
        两个ArrayList是“对齐”的，因此上面使用二分查找获取了下标，此时查询该字母在该单词id下的位置只需要O（1）
        2.1）查询需要的时间复杂度为O（N*log2（M）*M*L）其中N为用户输入的单词的长度，M为字母对应的倒排索引单词个数，L为字母在某个单词中的位置列表长度。
            第一个log2（M）是需要使用二分查找寻找某个id是否在当前字母的倒排表下的时间复杂度。后面那个M是需要遍历单词id的交集（仍是O(M)级别的）查找是否满足“前缀关系”与“缩写关系”。
        2.2）查询需要的额外空间为：输入字母个数*字母对应的倒排链上的单词个数*（id占用内存（4字节）+字母在单词中位置（2字节））
        2.3）整个倒排表占用内存稍小，查询的时间复杂度是HashMap方法的log2（M）倍。

6、测试用例:
倒排表使用hello world，help，hello enum构建
测试用例——hel e，输出结果—— [hello enum];
测试用例——he，输出结果—— [hello world, help, hello enum];
测试用例——，输出结果—— [];
测试用例——wo，输出结果—— [];
测试用例——hes，输出结果—— [];
测试用例——（空格）he（空格），输出结果—— [hello world, help, hello enum] ;