搜索结果排序的2.0版本也是根据公式计算出一个分值，其中分值的计算应当是搜索操作进行时才计算得到的
利用的特征有某个文本的点击数，浏览数，用户点赞数，发布的时间。
上面这些存放在sql中的column当中，其中发布时间在入库时已经确定，点击数与浏览数随着用户的操作来更新

score = [(log(clicks)*a) + (log(views)*b) +(likeCount-dislikeCount)*c]/[(inHours+1)+（inHours-lastLikeHours）*d]
1）其种a，b，c，d为权重，可以通过测试优化。
2）click为点击数：点击一次数据库中字段就更新一次。view为浏览数，在某个Document停留一定时间时触发。
    这两个会很大，因此采用log进行平滑。
3）点赞数与点踩数之差不会很大，可以直接使用
4）分母为发布时间与最后点赞时间——inHours计算入库时间与当前时间之差，+1是为了防止新发布问题分母过小，
    每一次点赞都会减小分母：如果点赞数增长很快，会抵消掉一部分时间的流逝带来的分值下降。
整个搜索流程为：
1）输入单词——根据TF与IDF的某种算法取与当前最相关的前XX个Document，拿到对应Document的id，分页显示。
2）只对当前分页下文档计算每个Document的score，完成排序，结果返回给前端。